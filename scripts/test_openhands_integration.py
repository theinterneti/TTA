#!/usr/bin/env python3
"""
Test script for OpenHands integration.

This script demonstrates how to programmatically invoke OpenHands for test generation.
Since OPENROUTER_API_KEY is not available, this uses mocks to simulate the workflow.

Usage:
    python scripts/test_openhands_integration.py

Features:
    - Demonstrates UnitTestGenerationService usage
    - Simulates test generation for callable_registry.py
    - Shows proper error handling
    - Validates generated tests
    - Provides detailed logging

Author: Augment Agent
Date: 2025-10-24
"""

import asyncio
import logging
import sys
from pathlib import Path
from typing import Any
from unittest.mock import AsyncMock, MagicMock, patch

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from pydantic import SecretStr

from src.agent_orchestration.openhands_integration.client import OpenHandsClient
from src.agent_orchestration.openhands_integration.config import OpenHandsConfig
from src.agent_orchestration.openhands_integration.models import OpenHandsTaskResult
from src.agent_orchestration.openhands_integration.test_generation_models import (
    TestTaskSpecification,
    TestValidationResult,
)
from src.agent_orchestration.openhands_integration.test_generation_service import (
    UnitTestGenerationService,
)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


# Mock test code that would be generated by OpenHands
MOCK_GENERATED_TEST_CODE = '''"""
Tests for CallableRegistry.

Tests thread-safe registry mapping ToolSpec to Python callables with version resolution.
"""

import pytest
import threading
from src.agent_orchestration.tools.callable_registry import CallableRegistry
from src.agent_orchestration.tools.models import ToolSpec


def sample_callable_v1():
    """Sample callable version 1."""
    return "v1"


def sample_callable_v2():
    """Sample callable version 2."""
    return "v2"


class TestCallableRegistry:
    """Tests for CallableRegistry."""

    def test_initialization(self):
        """Test registry initialization."""
        registry = CallableRegistry()
        assert registry._map == {}

    def test_register_callable(self):
        """Test registering a callable."""
        registry = CallableRegistry()
        registry.register_callable("test.tool", "1.0.0", sample_callable_v1)

        # Verify callable is registered
        registered = registry.get_registered()
        assert "test.tool" in registered
        assert "1.0.0" in registered["test.tool"]

    def test_register_multiple_versions(self):
        """Test registering multiple versions of same tool."""
        registry = CallableRegistry()
        registry.register_callable("test.tool", "1.0.0", sample_callable_v1)
        registry.register_callable("test.tool", "2.0.0", sample_callable_v2)

        registered = registry.get_registered()
        assert "test.tool" in registered
        assert "1.0.0" in registered["test.tool"]
        assert "2.0.0" in registered["test.tool"]

    def test_resolve_callable_exact_version(self):
        """Test resolving callable with exact version."""
        registry = CallableRegistry()
        registry.register_callable("test.tool", "1.0.0", sample_callable_v1)

        spec = ToolSpec(name="test.tool", version="1.0.0", description="Test")
        callable_fn = registry.resolve_callable(spec)

        assert callable_fn == sample_callable_v1
        assert callable_fn() == "v1"

    def test_resolve_callable_latest_version(self):
        """Test resolving callable with latest version fallback."""
        registry = CallableRegistry()
        registry.register_callable("test.tool", "1.0.0", sample_callable_v1)
        registry.register_callable("test.tool", "2.0.0", sample_callable_v2)

        # Request without version should get latest
        spec = ToolSpec(name="test.tool", version="", description="Test")
        callable_fn = registry.resolve_callable(spec)

        assert callable_fn == sample_callable_v2
        assert callable_fn() == "v2"

    def test_resolve_callable_not_found(self):
        """Test resolving non-existent callable raises ValueError."""
        registry = CallableRegistry()

        spec = ToolSpec(name="nonexistent.tool", version="1.0.0", description="Test")

        with pytest.raises(ValueError, match="No callable registered for tool"):
            registry.resolve_callable(spec)

    def test_thread_safety(self):
        """Test thread-safe registration and resolution."""
        registry = CallableRegistry()
        errors = []

        def register_and_resolve(version: str):
            try:
                registry.register_callable("test.tool", version, lambda: version)
                spec = ToolSpec(name="test.tool", version=version, description="Test")
                callable_fn = registry.resolve_callable(spec)
                assert callable_fn() == version
            except Exception as e:
                errors.append(e)

        # Create multiple threads
        threads = [
            threading.Thread(target=register_and_resolve, args=(f"{i}.0.0",))
            for i in range(10)
        ]

        # Start all threads
        for thread in threads:
            thread.start()

        # Wait for all threads
        for thread in threads:
            thread.join()

        # Verify no errors
        assert len(errors) == 0

    def test_get_registered_empty(self):
        """Test get_registered with empty registry."""
        registry = CallableRegistry()
        registered = registry.get_registered()
        assert registered == {}

    def test_get_registered_snapshot(self):
        """Test get_registered returns snapshot."""
        registry = CallableRegistry()
        registry.register_callable("test.tool", "1.0.0", sample_callable_v1)

        snapshot1 = registry.get_registered()
        registry.register_callable("test.tool", "2.0.0", sample_callable_v2)
        snapshot2 = registry.get_registered()

        # Snapshots should be different
        assert len(snapshot1["test.tool"]) == 1
        assert len(snapshot2["test.tool"]) == 2
'''


async def simulate_test_generation() -> TestValidationResult:
    """
    Simulate test generation for callable_registry.py using mocks.

    Returns:
        TestValidationResult with simulated validation results
    """
    logger.info("=" * 80)
    logger.info("SIMULATING OPENHANDS TEST GENERATION")
    logger.info("=" * 80)

    # Step 1: Create configuration
    logger.info("\n[Step 1] Creating OpenHands configuration...")
    config = OpenHandsConfig(
        api_key=SecretStr("mock-api-key-for-testing"),
        model="deepseek/deepseek-v3:free",
        base_url="https://openrouter.ai/api/v1",
        workspace_path=project_root,
        timeout_seconds=300.0,
    )
    logger.info(f"✓ Configuration created (workspace: {config.workspace_path})")

    # Step 2: Create test specification
    logger.info("\n[Step 2] Creating test specification...")
    spec = TestTaskSpecification(
        target_file=Path("src/agent_orchestration/tools/callable_registry.py"),
        coverage_threshold=70.0,
        test_directory=Path("tests"),
        timeout_seconds=300.0,
    )
    logger.info(f"✓ Test specification created:")
    logger.info(f"  - Target file: {spec.target_file}")
    logger.info(f"  - Coverage threshold: {spec.coverage_threshold}%")
    logger.info(f"  - Test directory: {spec.test_directory}")

    # Step 3: Create service
    logger.info("\n[Step 3] Creating UnitTestGenerationService...")
    service = UnitTestGenerationService(config)
    logger.info("✓ Service created")

    # Step 4: Mock OpenHandsClient.execute_task
    logger.info("\n[Step 4] Mocking OpenHands SDK (API key not available)...")
    with patch.object(OpenHandsClient, "execute_task", new_callable=AsyncMock) as mock_execute:
        # Simulate successful test generation
        mock_execute.return_value = OpenHandsTaskResult(
            success=True,
            output=f"Generated test file: tests/agent_orchestration/tools/test_callable_registry.py\n\n{MOCK_GENERATED_TEST_CODE}\n\nCoverage: 85.0%\nTests: 10 passed",
            error=None,
            execution_time=15.5,
            metadata={"tests_generated": 10, "coverage": 85.0},
        )
        logger.info("✓ Mock configured to return successful test generation")

        # Step 5: Mock file extraction
        logger.info("\n[Step 5] Mocking test file extraction...")
        with patch(
            "src.agent_orchestration.openhands_integration.test_generation_service.extract_test_files_from_output"
        ) as mock_extract:
            mock_extract.return_value = [
                Path("tests/agent_orchestration/tools/test_callable_registry.py")
            ]
            logger.info("✓ Mock configured to extract test file path")

            # Step 6: Mock validation
            logger.info("\n[Step 6] Mocking test validation...")
            with patch(
                "src.agent_orchestration.openhands_integration.test_generation_service.validate_generated_tests",
                new_callable=AsyncMock,
            ) as mock_validate:
                mock_validate.return_value = TestValidationResult(
                    syntax_valid=True,
                    conventions_followed=True,
                    tests_pass=True,
                    coverage_percentage=85.0,
                    issues=[],
                    quality_score=90.0,
                    test_file_path=Path("tests/agent_orchestration/tools/test_callable_registry.py"),
                )
                logger.info("✓ Mock configured to return successful validation")

                # Step 7: Execute test generation
                logger.info("\n[Step 7] Executing test generation...")
                result = await service.generate_tests(spec, max_iterations=5)

                logger.info("✓ Test generation completed")
                logger.info(f"\n[Results]")
                logger.info(f"  - Syntax valid: {result.syntax_valid}")
                logger.info(f"  - Conventions followed: {result.conventions_followed}")
                logger.info(f"  - Tests pass: {result.tests_pass}")
                logger.info(f"  - Coverage: {result.coverage_percentage}%")
                logger.info(f"  - Quality score: {result.quality_score}")
                logger.info(f"  - Test file: {result.test_file_path}")
                logger.info(f"  - Issues: {result.issues if result.issues else 'None'}")

                return result


async def main():
    """Main entry point."""
    try:
        logger.info("OpenHands Integration Test Script")
        logger.info("=" * 80)
        logger.info("This script demonstrates programmatic invocation of OpenHands")
        logger.info("for test generation. Since OPENROUTER_API_KEY is not available,")
        logger.info("this uses mocks to simulate the workflow.")
        logger.info("=" * 80)

        # Run simulation
        result = await simulate_test_generation()

        # Display summary
        logger.info("\n" + "=" * 80)
        logger.info("SIMULATION SUMMARY")
        logger.info("=" * 80)
        logger.info(f"✓ Test generation workflow completed successfully")
        logger.info(f"✓ All validation checks passed")
        logger.info(f"✓ Coverage threshold met: {result.coverage_percentage}% >= 70%")
        logger.info(f"✓ Quality score: {result.quality_score}/100")
        logger.info("\nNOTE: This was a simulated run using mocks.")
        logger.info("To run with real OpenHands:")
        logger.info("  1. Set OPENROUTER_API_KEY environment variable")
        logger.info("  2. Remove mock patches from this script")
        logger.info("  3. Run: python scripts/test_openhands_integration.py")
        logger.info("=" * 80)

        return 0

    except Exception as e:
        logger.error(f"\n✗ Error during test generation: {e}", exc_info=True)
        return 1


if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except Exception as e:
        print(f"FATAL ERROR: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)

