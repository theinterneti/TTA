#!/usr/bin/env ts-node

/**
 * Results Analysis Script
 *
 * Analyzes existing simulation results and generates insights
 */

import * as fs from 'fs';
import * as path from 'path';
import { SimulationResults, SimulationStatistics } from '../types/SimulationTypes';
import { ResultsAnalyzer, AnalysisReport } from '../analysis/ResultsAnalyzer';
import { PersonaType } from '../personas/UserPersonas';

interface AnalysisOptions {
  inputFile?: string;
  outputFile?: string;
  format?: 'json' | 'markdown' | 'csv';
  includeCharts?: boolean;
  compareBaseline?: boolean;
  baselineFile?: string;
}

/**
 * Load simulation results from file
 */
function loadResults(filePath: string): SimulationResults {
  try {
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    console.error(`Failed to load results from ${filePath}:`, error);
    throw error;
  }
}

/**
 * Save analysis report to file
 */
function saveReport(report: AnalysisReport, filePath: string, format: string): void {
  try {
    let content: string;

    switch (format) {
      case 'json':
        content = JSON.stringify(report, null, 2);
        break;
      case 'markdown':
        content = generateMarkdownReport(report);
        break;
      case 'csv':
        content = generateCSVReport(report);
        break;
      default:
        throw new Error(`Unsupported format: ${format}`);
    }

    fs.writeFileSync(filePath, content, 'utf8');
    console.log(`✅ Report saved to ${filePath}`);
  } catch (error) {
    console.error(`Failed to save report to ${filePath}:`, error);
    throw error;
  }
}

/**
 * Generate markdown report
 */
function generateMarkdownReport(report: AnalysisReport): string {
  const timestamp = new Date(report.timestamp).toISOString();

  return `# TTA Simulation Analysis Report

**Generated:** ${timestamp}
**Analysis Time:** ${report.analysisTime}ms

## Executive Summary

### Overall Scores
- **World Generation:** ${(report.overallScores.worldGenerationScore * 100).toFixed(1)}%
- **Immersion:** ${(report.overallScores.immersionScore * 100).toFixed(1)}%
- **Engagement:** ${(report.overallScores.engagementScore * 100).toFixed(1)}%
- **Therapeutic Integration:** ${(report.overallScores.therapeuticIntegrationScore * 100).toFixed(1)}%
- **Entertainment Value:** ${(report.overallScores.entertainmentValueScore * 100).toFixed(1)}%

### Success Criteria
${Object.entries(report.successCriteria).map(([criterion, passed]) =>
  `- **${criterion}:** ${passed ? '✅ PASS' : '❌ FAIL'}`
).join('\n')}

## Key Statistics

- **Total Sessions:** ${report.statistics.totalSessions}
- **Total Personas:** ${report.statistics.totalPersonas}
- **Total Scenarios:** ${report.statistics.totalScenarios}
- **Average Session Duration:** ${report.statistics.averageSessionDuration.toFixed(1)} minutes
- **Average Engagement:** ${(report.statistics.averageEngagement * 100).toFixed(1)}%
- **Average Immersion:** ${(report.statistics.averageImmersion * 100).toFixed(1)}%
- **Scenario Success Rate:** ${report.statistics.scenarioSuccessRate.toFixed(1)}%

## Key Findings

${report.keyFindings.map(finding => `- ${finding}`).join('\n')}

## Persona Insights

${Object.entries(report.personaInsights).map(([persona, insights]) => `
### ${persona}
${insights.map(insight => `- ${insight}`).join('\n')}
`).join('\n')}

## Recommendations

### Improvement Priorities
${report.improvementPriorities.map((priority, index) => `${index + 1}. ${priority}`).join('\n')}

### Detailed Recommendations
${report.recommendations.map((rec, index) => `${index + 1}. ${rec}`).join('\n')}

## Session Quality Assessment

**High Quality Sessions:** ${report.sessionAssessments.filter(s => s.qualityScore > 0.8).length}
**Medium Quality Sessions:** ${report.sessionAssessments.filter(s => s.qualityScore >= 0.6 && s.qualityScore <= 0.8).length}
**Low Quality Sessions:** ${report.sessionAssessments.filter(s => s.qualityScore < 0.6).length}

## World Generation Assessment

**High Quality Worlds:** ${report.worldAssessments.filter(w => w.overallQuality > 0.8).length}
**Medium Quality Worlds:** ${report.worldAssessments.filter(w => w.overallQuality >= 0.6 && w.overallQuality <= 0.8).length}
**Low Quality Worlds:** ${report.worldAssessments.filter(w => w.overallQuality < 0.6).length}

---
*Generated by TTA Simulation Framework*`;
}

/**
 * Generate CSV report
 */
function generateCSVReport(report: AnalysisReport): string {
  const headers = [
    'Metric',
    'Value',
    'Category'
  ];

  const rows: string[][] = [
    headers,
    ['World Generation Score', (report.overallScores.worldGenerationScore * 100).toFixed(1) + '%', 'Overall'],
    ['Immersion Score', (report.overallScores.immersionScore * 100).toFixed(1) + '%', 'Overall'],
    ['Engagement Score', (report.overallScores.engagementScore * 100).toFixed(1) + '%', 'Overall'],
    ['Therapeutic Integration Score', (report.overallScores.therapeuticIntegrationScore * 100).toFixed(1) + '%', 'Overall'],
    ['Entertainment Value Score', (report.overallScores.entertainmentValueScore * 100).toFixed(1) + '%', 'Overall'],
    ['Total Sessions', report.statistics.totalSessions.toString(), 'Statistics'],
    ['Total Personas', report.statistics.totalPersonas.toString(), 'Statistics'],
    ['Average Session Duration', report.statistics.averageSessionDuration.toFixed(1) + ' min', 'Statistics'],
    ['Average Engagement', (report.statistics.averageEngagement * 100).toFixed(1) + '%', 'Statistics'],
    ['Average Immersion', (report.statistics.averageImmersion * 100).toFixed(1) + '%', 'Statistics'],
    ['Scenario Success Rate', report.statistics.scenarioSuccessRate.toFixed(1) + '%', 'Statistics']
  ];

  return rows.map(row => row.join(',')).join('\n');
}

/**
 * Compare two simulation results
 */
function compareResults(current: SimulationResults, baseline: SimulationResults): void {
  console.log('\n📊 COMPARISON WITH BASELINE\n');

  const currentStats = current.statistics;
  const baselineStats = baseline.statistics;

  const comparisons = [
    {
      metric: 'Average Engagement',
      current: currentStats.averageEngagement,
      baseline: baselineStats.averageEngagement,
      format: (val: number) => `${(val * 100).toFixed(1)}%`
    },
    {
      metric: 'Average Immersion',
      current: currentStats.averageImmersion,
      baseline: baselineStats.averageImmersion,
      format: (val: number) => `${(val * 100).toFixed(1)}%`
    },
    {
      metric: 'Scenario Success Rate',
      current: currentStats.scenarioSuccessRate,
      baseline: baselineStats.scenarioSuccessRate,
      format: (val: number) => `${val.toFixed(1)}%`
    },
    {
      metric: 'Average Session Duration',
      current: currentStats.averageSessionDuration,
      baseline: baselineStats.averageSessionDuration,
      format: (val: number) => `${val.toFixed(1)} min`
    }
  ];

  comparisons.forEach(({ metric, current, baseline, format }) => {
    const change = ((current - baseline) / baseline) * 100;
    const changeStr = change > 0 ? `+${change.toFixed(1)}%` : `${change.toFixed(1)}%`;
    const indicator = change > 0 ? '📈' : change < 0 ? '📉' : '➡️';

    console.log(`${indicator} ${metric}:`);
    console.log(`   Current: ${format(current)}`);
    console.log(`   Baseline: ${format(baseline)}`);
    console.log(`   Change: ${changeStr}\n`);
  });
}

/**
 * Generate persona performance summary
 */
function generatePersonaSummary(statistics: SimulationStatistics): void {
  console.log('\n👥 PERSONA PERFORMANCE SUMMARY\n');

  const personaEntries = Object.entries(statistics.personaStatistics)
    .sort(([,a], [,b]) => b.averageEngagement - a.averageEngagement);

  personaEntries.forEach(([persona, stats], index) => {
    const rank = index + 1;
    const medal = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `${rank}.`;

    console.log(`${medal} ${persona}`);
    console.log(`   Engagement: ${(stats.averageEngagement * 100).toFixed(1)}%`);
    console.log(`   Immersion: ${(stats.averageImmersion * 100).toFixed(1)}%`);
    console.log(`   Therapeutic Benefit: ${(stats.averageTherapeuticBenefit * 100).toFixed(1)}%`);
    console.log(`   Completion Rate: ${(stats.completionRate * 100).toFixed(1)}%`);
    console.log(`   Sessions: ${stats.sessionCount}\n`);
  });
}

/**
 * Main analysis function
 */
async function analyzeResults(options: AnalysisOptions): Promise<void> {
  const inputFile = options.inputFile || 'simulation-results.json';
  const outputFile = options.outputFile || `analysis-report-${Date.now()}.${options.format || 'json'}`;

  console.log('📊 TTA Simulation Results Analysis');
  console.log(`📁 Input: ${inputFile}`);
  console.log(`📄 Output: ${outputFile}`);
  console.log('');

  try {
    // Load results
    console.log('Loading simulation results...');
    const results = loadResults(inputFile);

    // Create analyzer
    const analyzer = new ResultsAnalyzer({
      includeDetailedBreakdown: true,
      generateVisualReports: options.includeCharts || false,
      compareWithBaseline: options.compareBaseline || false,
      baselineResultsPath: options.baselineFile,
      exportFormat: 'json',
      includeRawData: true,
      confidenceLevel: 0.95
    });

    // Analyze results
    console.log('Analyzing results...');
    const report = await analyzer.analyzeResults(results);

    // Save report
    saveReport(report, outputFile, options.format || 'json');

    // Display summary
    console.log('\n' + '='.repeat(60));
    console.log('📊 ANALYSIS SUMMARY');
    console.log('='.repeat(60));

    console.log(`\n🎯 Overall Success: ${Object.values(report.successCriteria).every(Boolean) ? '✅ PASS' : '⚠️ NEEDS IMPROVEMENT'}`);
    console.log(`📈 Key Metrics:`);
    console.log(`   Engagement: ${(report.overallScores.engagementScore * 100).toFixed(1)}%`);
    console.log(`   Immersion: ${(report.overallScores.immersionScore * 100).toFixed(1)}%`);
    console.log(`   Therapeutic Integration: ${(report.overallScores.therapeuticIntegrationScore * 100).toFixed(1)}%`);
    console.log(`   Entertainment Value: ${(report.overallScores.entertainmentValueScore * 100).toFixed(1)}%`);

    // Generate persona summary
    generatePersonaSummary(report.statistics);

    // Compare with baseline if requested
    if (options.compareBaseline && options.baselineFile) {
      const baseline = loadResults(options.baselineFile);
      compareResults(results, baseline);
    }

    console.log('🔍 Top Findings:');
    report.keyFindings.slice(0, 3).forEach(finding => console.log(`   • ${finding}`));

    console.log('\n🎯 Priority Recommendations:');
    report.improvementPriorities.slice(0, 3).forEach(rec => console.log(`   • ${rec}`));

    console.log('\n✅ Analysis completed successfully!');

  } catch (error) {
    console.error('❌ Analysis failed:', error);
    process.exit(1);
  }
}

/**
 * Main execution
 */
async function main(): Promise<void> {
  const args = process.argv.slice(2);

  const options: AnalysisOptions = {
    inputFile: args.find(arg => arg.startsWith('--input='))?.split('=')[1],
    outputFile: args.find(arg => arg.startsWith('--output='))?.split('=')[1],
    format: args.find(arg => arg.startsWith('--format='))?.split('=')[1] as 'json' | 'markdown' | 'csv',
    includeCharts: args.includes('--charts'),
    compareBaseline: args.includes('--compare'),
    baselineFile: args.find(arg => arg.startsWith('--baseline='))?.split('=')[1]
  };

  if (args.includes('--help')) {
    console.log(`
TTA Simulation Results Analyzer

Usage: ts-node analyzeResults.ts [options]

Options:
  --input=FILE      Input simulation results file (default: simulation-results.json)
  --output=FILE     Output analysis report file (default: analysis-report-[timestamp].[format])
  --format=FORMAT   Output format: json, markdown, csv (default: json)
  --charts          Include visual charts in report
  --compare         Compare with baseline results
  --baseline=FILE   Baseline results file for comparison
  --help            Show this help message

Examples:
  ts-node analyzeResults.ts --input=results.json --format=markdown
  ts-node analyzeResults.ts --compare --baseline=baseline.json --charts
  ts-node analyzeResults.ts --output=report.csv --format=csv
`);
    return;
  }

  await analyzeResults(options);
}

// Run if called directly
if (require.main === module) {
  main().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}

export { analyzeResults, loadResults, generateMarkdownReport, generateCSVReport };
