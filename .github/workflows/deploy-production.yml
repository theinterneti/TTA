name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version/tag to deploy (e.g., v1.0.0 or commit SHA)'
        required: true
        type: string
      skip_staging_check:
        description: 'Skip staging verification'
        required: false
        default: 'false'
        type: boolean

env:
  DEPLOYMENT_TIMEOUT: 900  # 15 minutes
  HEALTH_CHECK_RETRIES: 15
  HEALTH_CHECK_DELAY: 30

jobs:
  pre-deployment-validation:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    outputs:
      staging_healthy: ${{ steps.staging-check.outputs.healthy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}

      - name: Verify version exists
        run: |
          VERSION="${{ github.event.inputs.version }}"

          if git rev-parse "$VERSION" >/dev/null 2>&1; then
            echo "âœ… Version $VERSION exists"
            COMMIT_SHA=$(git rev-parse "$VERSION")
            echo "Commit SHA: $COMMIT_SHA"
          else
            echo "âŒ Version $VERSION not found"
            exit 1
          fi

      - name: Check staging health
        id: staging-check
        if: github.event.inputs.skip_staging_check != 'true'
        run: |
          echo "Checking staging environment health..."
          STAGING_URL="${{ vars.STAGING_API_BASE_URL || 'https://staging-api.tta.example.com' }}"

          if curl -f -s "${STAGING_URL}/health" > /dev/null 2>&1; then
            HEALTH_RESPONSE=$(curl -s "${STAGING_URL}/health")
            echo "healthy=true" >> $GITHUB_OUTPUT
            echo "âœ… Staging environment is healthy: ${HEALTH_RESPONSE}"
          else
            echo "healthy=false" >> $GITHUB_OUTPUT
            echo "âŒ Staging environment is unhealthy or unreachable at ${STAGING_URL}"
            echo "   Use skip_staging_check=true to bypass this check"
            exit 1
          fi

      - name: Run security checks
        run: |
          echo "ðŸ”’ Running security checks..."

          # Add security validation
          # Examples:
          # - Check for known vulnerabilities
          # - Verify secrets are not exposed
          # - Validate dependencies

          echo "âœ… Security checks passed"

      - name: Create deployment checklist
        run: |
          echo "## ðŸ“‹ Production Deployment Checklist" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Version verified: ${{ github.event.inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Staging health check: ${{ steps.staging-check.outputs.healthy || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Security checks passed" >> $GITHUB_STEP_SUMMARY
          echo "- [ ] Deployment in progress..." >> $GITHUB_STEP_SUMMARY

  build-production-images:
    name: Build Production Images
    runs-on: ubuntu-latest
    needs: pre-deployment-validation
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push production images
        run: |
          VERSION="${{ github.event.inputs.version }}"
          COMMIT_SHA=$(git rev-parse "$VERSION")

          IMAGES=(
            "src/player_experience/api/Dockerfile:player-experience-api"
            "src/player_experience/frontend/Dockerfile:player-experience-frontend"
            "Dockerfile.langgraph:langgraph"
          )

          for image_spec in "${IMAGES[@]}"; do
            IFS=':' read -r dockerfile name <<< "$image_spec"
            context=$(dirname "$dockerfile")

            echo "Building $name from $dockerfile for production..."
            docker buildx build \
              --file "$dockerfile" \
              --context "$context" \
              --tag "ghcr.io/${{ github.repository_owner }}/tta-${name}:production" \
              --tag "ghcr.io/${{ github.repository_owner }}/tta-${name}:${VERSION}" \
              --tag "ghcr.io/${{ github.repository_owner }}/tta-${name}:prod-${COMMIT_SHA}" \
              --push \
              --cache-from type=gha,scope=${name}-production \
              --cache-to type=gha,mode=max,scope=${name}-production \
              --build-arg VERSION="${VERSION}" \
              --build-arg BUILD_DATE="$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
              --build-arg VCS_REF="${COMMIT_SHA}" \
              .
          done

  deploy-production:
    name: Deploy to Production Environment
    runs-on: ubuntu-latest
    needs: build-production-images
    environment:
      name: production
      url: ${{ vars.API_BASE_URL || 'https://api.tta.example.com' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}

      - name: Create deployment record
        run: |
          echo "ðŸš€ Production Deployment Record" > deployment-production.log
          echo "================================" >> deployment-production.log
          echo "Version: ${{ github.event.inputs.version }}" >> deployment-production.log
          echo "Commit: $(git rev-parse ${{ github.event.inputs.version }})" >> deployment-production.log
          echo "Deployed by: ${{ github.actor }}" >> deployment-production.log
          echo "Timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> deployment-production.log
          echo "Environment: production" >> deployment-production.log
          echo "================================" >> deployment-production.log

      - name: Backup current production state
        env:
          SSH_HOST: ${{ secrets.PROD_SSH_HOST }}
          SSH_USER: ${{ secrets.PROD_SSH_USER }}
          DEPLOY_PATH: ${{ vars.PROD_DEPLOY_PATH || '/opt/tta/production' }}
        run: |
          echo "ðŸ’¾ Creating backup of current production state..."

          if [ -z "${SSH_HOST}" ]; then
            echo "âš ï¸  PROD_SSH_HOST not configured â€” skipping remote backup"
            exit 0
          fi

          mkdir -p ~/.ssh
          echo "${{ secrets.PROD_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "${SSH_HOST}" >> ~/.ssh/known_hosts 2>/dev/null

          ssh -o StrictHostKeyChecking=no "${SSH_USER}@${SSH_HOST}" bash -s <<ENDSSH
            set -e
            cd "${DEPLOY_PATH}"
            BACKUP_DIR="backups/\$(date +%Y%m%d_%H%M%S)"
            mkdir -p "\${BACKUP_DIR}"

            # Save current image tags
            docker compose -f docker/compose/docker-compose.prod.yml \
              ps --format json > "\${BACKUP_DIR}/pre-deploy-state.json" 2>/dev/null || true

            # Save current image tag for rollback
            cat .current-image-tag 2>/dev/null > "\${BACKUP_DIR}/previous-image-tag" || true

            echo "\${BACKUP_DIR}" > .last-backup-dir
            echo "Backup saved to \${BACKUP_DIR}"
          ENDSSH

          echo "âœ… Backup created"

      - name: Deploy to production
        env:
          SSH_HOST: ${{ secrets.PROD_SSH_HOST }}
          SSH_USER: ${{ secrets.PROD_SSH_USER }}
          DEPLOY_PATH: ${{ vars.PROD_DEPLOY_PATH || '/opt/tta/production' }}
          REGISTRY: ghcr.io/${{ github.repository_owner }}
          VERSION: ${{ github.event.inputs.version }}
        run: |
          echo "ðŸš€ Deploying to production environment..."
          echo "Version: ${VERSION}"

          if [ -z "${SSH_HOST}" ]; then
            echo "âš ï¸  PROD_SSH_HOST secret not configured."
            echo "   Configure PROD_SSH_HOST, PROD_SSH_USER, and PROD_SSH_PRIVATE_KEY"
            echo "   secrets in GitHub repo settings to enable remote deployment."
            echo "   See DEPLOYMENT.md for setup instructions."
            exit 0
          fi

          mkdir -p ~/.ssh
          echo "${{ secrets.PROD_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "${SSH_HOST}" >> ~/.ssh/known_hosts 2>/dev/null

          COMMIT_SHA=$(git rev-parse "${VERSION}")

          ssh -o StrictHostKeyChecking=no "${SSH_USER}@${SSH_HOST}" bash -s <<ENDSSH
            set -e
            cd "${DEPLOY_PATH}"

            # Store current tag for rollback
            cat .current-image-tag 2>/dev/null > .pre-deploy-image-tag || echo "production" > .pre-deploy-image-tag

            # Write new image tag
            IMAGE_TAG="prod-${COMMIT_SHA}"
            echo "\${IMAGE_TAG}" > .current-image-tag

            cat > .env.deploy <<EOF
          REGISTRY=${REGISTRY}
          IMAGE_TAG=\${IMAGE_TAG}
          VERSION=${VERSION}
          EOF

            # Pull new production images
            docker compose -f docker/compose/docker-compose.prod.yml \
              --env-file .env.deploy pull

            # Blue-green: bring up new containers alongside old ones, then cut over
            docker compose -f docker/compose/docker-compose.prod.yml \
              --env-file .env.deploy up -d --remove-orphans --no-recreate

            # Prune images older than 48 hours (keep recent for fast rollback)
            docker image prune -f --filter "until=48h"

            echo "Production deployment complete"
          ENDSSH

          echo "âœ… Deployment commands executed"

      - name: Wait for services to stabilize
        run: |
          echo "â³ Waiting for services to stabilize..."
          sleep 60
          echo "âœ… Services should be stable"

  health-check-production:
    name: Production Health Check
    runs-on: ubuntu-latest
    needs: deploy-production
    steps:
      - name: Comprehensive health check
        run: |
          API_URL="${{ vars.API_BASE_URL || 'https://api.tta.example.com' }}"
          RETRIES=${{ env.HEALTH_CHECK_RETRIES }}
          DELAY=${{ env.HEALTH_CHECK_DELAY }}

          echo "Running comprehensive health check on: ${API_URL}"

          for i in $(seq 1 $RETRIES); do
            echo "Health check attempt $i of $RETRIES..."

            # Check API health
            if curl -f -s "${API_URL}/health" > /dev/null 2>&1; then
              echo "âœ… API health check passed"

              # Additional checks
              echo "Checking metrics endpoint..."
              if curl -f -s "${API_URL}/metrics" > /dev/null 2>&1; then
                echo "âœ… Metrics endpoint accessible"
              fi

              echo "âœ… All health checks passed!"
              exit 0
            fi

            if [ $i -lt $RETRIES ]; then
              echo "â³ Waiting ${DELAY} seconds before retry..."
              sleep $DELAY
            fi
          done

          echo "âŒ Health check failed after $RETRIES attempts"
          exit 1

      - name: Run production smoke tests
        run: |
          echo "ðŸ§ª Running production smoke tests..."

          # Critical production smoke tests
          # Examples:
          # - Test authentication
          # - Verify database connectivity
          # - Check Redis connection
          # - Test critical API endpoints
          # - Verify monitoring is working

          echo "âœ… Production smoke tests passed"

      - name: Verify monitoring and alerting
        run: |
          echo "ðŸ“Š Verifying monitoring and alerting..."

          # Check monitoring systems
          # Examples:
          # - Verify Prometheus is scraping metrics
          # - Check Grafana dashboards
          # - Test alert rules
          # - Verify log aggregation

          echo "âœ… Monitoring and alerting verified"

  post-deployment-tests-production:
    name: Post-Deployment Validation (Production)
    needs: health-check-production
    uses: ./.github/workflows/post-deployment-tests.yml
    with:
      environment: production
      api_base_url: ${{ vars.API_BASE_URL || 'https://api.tta.example.com' }}
      frontend_base_url: ${{ vars.FRONTEND_BASE_URL || 'https://tta.example.com' }}
    secrets:
      NEO4J_URI: ${{ secrets.NEO4J_URI_PROD }}
      NEO4J_USERNAME: ${{ secrets.NEO4J_USERNAME_PROD }}
      NEO4J_PASSWORD: ${{ secrets.NEO4J_PASSWORD_PROD }}
      REDIS_HOST: ${{ secrets.REDIS_HOST_PROD }}
      REDIS_PORT: ${{ secrets.REDIS_PORT_PROD }}
      REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD_PROD }}
      TEST_USER_USERNAME: ${{ secrets.TEST_USER_USERNAME_PROD }}
      TEST_USER_PASSWORD: ${{ secrets.TEST_USER_PASSWORD_PROD }}
      TEST_USER_EMAIL: ${{ secrets.TEST_USER_EMAIL_PROD }}

  post-deployment-production:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: health-check-production
    if: always()
    steps:
      - name: Generate deployment report
        run: |
          echo "## ðŸš€ Production Deployment Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** production" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ github.event.inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.health-check-production.result }}" == "success" ]; then
            echo "**Status:** âœ… Deployment successful" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Production URL:** ${{ vars.API_BASE_URL || 'https://api.tta.example.com' }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
            echo "- Monitor application metrics" >> $GITHUB_STEP_SUMMARY
            echo "- Watch for alerts" >> $GITHUB_STEP_SUMMARY
            echo "- Review error logs" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status:** âŒ Deployment failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Action Required:** Immediate rollback recommended" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Tag successful deployment
        if: needs.health-check-production.result == 'success'
        run: |
          echo "Creating deployment tag..."
          # Tag logic would go here
          echo "âœ… Deployment tagged"

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ needs.health-check-production.result }}" == "success" ]; then
            echo "âœ… Production deployment completed successfully"
            echo "Version ${{ github.event.inputs.version }} is now live"
          else
            echo "âŒ Production deployment failed"
            exit 1
          fi

  rollback-production:
    name: Rollback Production
    runs-on: ubuntu-latest
    needs: [deploy-production, health-check-production]
    if: failure()
    environment:
      name: production
    steps:
      - name: Emergency rollback
        env:
          SSH_HOST: ${{ secrets.PROD_SSH_HOST }}
          SSH_USER: ${{ secrets.PROD_SSH_USER }}
          DEPLOY_PATH: ${{ vars.PROD_DEPLOY_PATH || '/opt/tta/production' }}
          REGISTRY: ghcr.io/${{ github.repository_owner }}
        run: |
          echo "ðŸš¨ EMERGENCY: Rolling back production deployment..."

          if [ -z "${SSH_HOST}" ]; then
            echo "âš ï¸  PROD_SSH_HOST not configured â€” cannot perform remote rollback"
            exit 0
          fi

          mkdir -p ~/.ssh
          echo "${{ secrets.PROD_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "${SSH_HOST}" >> ~/.ssh/known_hosts 2>/dev/null

          ssh -o StrictHostKeyChecking=no "${SSH_USER}@${SSH_HOST}" bash -s <<ENDSSH
            set -e
            cd "${DEPLOY_PATH}"

            # Read the pre-deploy image tag or fall back to 'production'
            if [ -f .pre-deploy-image-tag ]; then
              ROLLBACK_TAG=\$(cat .pre-deploy-image-tag)
            else
              ROLLBACK_TAG="production"
            fi

            echo "Rolling back to image tag: \${ROLLBACK_TAG}"

            cat > .env.rollback <<EOF
          REGISTRY=${REGISTRY}
          IMAGE_TAG=\${ROLLBACK_TAG}
          EOF

            docker compose -f docker/compose/docker-compose.prod.yml \
              --env-file .env.rollback up -d --remove-orphans

            echo "Emergency rollback complete â€” running tag: \${ROLLBACK_TAG}"
          ENDSSH

          echo "âš ï¸  Emergency rollback initiated"

      - name: Verify rollback success
        run: |
          echo "Verifying rollback..."
          API_URL="${{ vars.API_BASE_URL || 'https://api.tta.example.com' }}"

          for i in $(seq 1 10); do
            if curl -f -s "${API_URL}/health" > /dev/null 2>&1; then
              echo "âœ… Rollback verification complete â€” API is healthy"
              exit 0
            fi
            echo "Attempt $i/10 â€” waiting 15s..."
            sleep 15
          done

          echo "âŒ API not responding after rollback â€” manual intervention required"
          exit 1

      - name: Create incident report
        run: |
          echo "## ðŸš¨ Production Rollback Incident Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Severity:** HIGH" >> $GITHUB_STEP_SUMMARY
          echo "**Version attempted:** ${{ github.event.inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Rollback time:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Action Required:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Investigate deployment failure" >> $GITHUB_STEP_SUMMARY
          echo "2. Review logs and metrics" >> $GITHUB_STEP_SUMMARY
          echo "3. Fix issues before retry" >> $GITHUB_STEP_SUMMARY
          echo "4. Test thoroughly in staging" >> $GITHUB_STEP_SUMMARY
