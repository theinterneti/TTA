name: PR Automation - Auto-assign, Review & Merge

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  auto-assign-reviewers:
    name: Auto-assign Reviewers
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'pull_request' &&
      (github.event.action == 'opened' || github.event.action == 'ready_for_review')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Assign reviewers based on CODEOWNERS
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Read CODEOWNERS if it exists
            let codeowners = [];
            const codeownersPath = path.join(process.env.GITHUB_WORKSPACE, '.github', 'CODEOWNERS');

            if (fs.existsSync(codeownersPath)) {
              const content = fs.readFileSync(codeownersPath, 'utf8');
              codeowners = content
                .split('\n')
                .filter(line => line.trim() && !line.startsWith('#'))
                .map(line => {
                  const parts = line.trim().split(/\s+/);
                  return {
                    pattern: parts[0],
                    owners: parts.slice(1).map(o => o.replace('@', ''))
                  };
                });
            }

            // Get changed files
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            // Find matching owners
            const reviewers = new Set();
            for (const file of files) {
              for (const rule of codeowners) {
                // Simple pattern matching (can be enhanced)
                if (file.filename.includes(rule.pattern.replace('*', ''))) {
                  rule.owners.forEach(owner => reviewers.add(owner));
                }
              }
            }

            // Fallback to default reviewers if no CODEOWNERS matches
            if (reviewers.size === 0) {
              // Default reviewers based on file types
              const fileTypes = {
                python: files.some(f => f.filename.endsWith('.py')),
                typescript: files.some(f => f.filename.match(/\.(ts|tsx)$/)),
                docker: files.some(f => f.filename.includes('Dockerfile') || f.filename.includes('docker-compose')),
                tests: files.some(f => f.filename.includes('test')),
                docs: files.some(f => f.filename.endsWith('.md')),
                github: files.some(f => f.filename.includes('.github/'))
              };

              // Smart reviewer assignment
              if (fileTypes.python || fileTypes.tests) {
                reviewers.add('theinterneti'); // Backend/testing expert
              }
              if (fileTypes.typescript) {
                reviewers.add('theinterneti'); // Frontend expert
              }
              if (fileTypes.docker || fileTypes.github) {
                reviewers.add('theinterneti'); // DevOps expert
              }
            }

            // Remove PR author from reviewers
            reviewers.delete(context.payload.pull_request.user.login);

            const reviewersList = Array.from(reviewers);

            if (reviewersList.length > 0) {
              try {
                await github.rest.pulls.requestReviewers({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  reviewers: reviewersList
                });

                core.info(`‚úÖ Assigned reviewers: ${reviewersList.join(', ')}`);
              } catch (error) {
                core.warning(`Failed to assign reviewers: ${error.message}`);
              }
            }

            // Add labels based on changes
            const labels = [];
            if (fileTypes.python) labels.push('backend');
            if (fileTypes.typescript) labels.push('frontend');
            if (fileTypes.tests) labels.push('testing');
            if (fileTypes.docker) labels.push('infrastructure');
            if (fileTypes.docs) labels.push('documentation');

            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: labels
              });
            }

  copilot-review:
    name: Copilot Code Review
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'pull_request' &&
      !github.event.pull_request.draft

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Wait for Copilot review
        uses: actions/github-script@v7
        with:
          script: |
            // Wait for Copilot to complete its review
            const maxWaitTime = 5 * 60 * 1000; // 5 minutes
            const checkInterval = 10 * 1000; // 10 seconds
            const startTime = Date.now();

            core.info('‚è≥ Waiting for GitHub Copilot to complete review...');

            while (Date.now() - startTime < maxWaitTime) {
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });

              const copilotReview = reviews.find(r =>
                r.user.login === 'copilot' ||
                r.user.login.includes('copilot')
              );

              if (copilotReview) {
                core.info(`‚úÖ Copilot review completed: ${copilotReview.state}`);
                return copilotReview;
              }

              await new Promise(resolve => setTimeout(resolve, checkInterval));
            }

            core.warning('‚ö†Ô∏è Copilot review timeout - proceeding without waiting');

      - name: Analyze Copilot comments
        uses: actions/github-script@v7
        with:
          script: |
            const { data: comments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const copilotComments = comments.filter(c =>
              c.user.login.includes('copilot')
            );

            if (copilotComments.length === 0) {
              core.info('‚úÖ No Copilot review comments found');
              return;
            }

            // Categorize comments
            const unresolved = copilotComments.filter(c => !c.resolved);
            const critical = copilotComments.filter(c =>
              c.body.toLowerCase().includes('critical') ||
              c.body.toLowerCase().includes('security') ||
              c.body.toLowerCase().includes('error')
            );

            // Create summary
            const summary = `
## ü§ñ Copilot Review Summary

**Total Comments**: ${copilotComments.length}
**Unresolved**: ${unresolved.length}
**Critical**: ${critical.length}

${critical.length > 0 ? '### ‚ö†Ô∏è Critical Issues\n' + critical.map(c => `- ${c.path}:${c.line} - ${c.body.substring(0, 100)}...`).join('\n') : ''}

---
*Review the [full Copilot review](${context.payload.pull_request.html_url}/files) for details.*
            `.trim();

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: summary
            });

            // Set PR check status
            if (critical.length > 0) {
              core.setFailed(`‚ùå ${critical.length} critical issues found by Copilot`);
            }

  quality-gates:
    name: Quality Gate Checks
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'pull_request' &&
      !github.event.pull_request.draft

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install UV
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH

      - name: Install dependencies
        run: uv sync --all-extras

      - name: Run quality checks
        run: |
          uv run ruff check src/ tests/ --output-format=github
          uv run ruff format src/ tests/ --check
          uvx pyright src/

      - name: Check test coverage
        run: |
          uv run pytest tests/ --cov=src --cov-report=json --cov-report=term

          # Parse coverage and set as output
          COVERAGE=$(python -c "import json; print(json.load(open('coverage.json'))['totals']['percent_covered'])")
          echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
        id: coverage

      - name: Comment coverage on PR
        uses: actions/github-script@v7
        with:
          script: |
            const coverage = parseFloat('${{ steps.coverage.outputs.coverage }}');
            const threshold = 70;
            const emoji = coverage >= threshold ? '‚úÖ' : '‚ö†Ô∏è';

            const body = `
## ${emoji} Code Coverage Report

**Current Coverage**: ${coverage.toFixed(2)}%
**Required**: ${threshold}%

${coverage >= threshold
              ? '‚úÖ Coverage threshold met!'
              : '‚ö†Ô∏è Coverage below threshold - please add tests'}

---
View detailed coverage report in the workflow artifacts.
            `.trim();

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });

  auto-merge:
    name: Auto-Merge PR
    runs-on: ubuntu-latest
    needs: [auto-assign-reviewers, quality-gates]
    if: |
      github.event_name == 'pull_request' &&
      !github.event.pull_request.draft &&
      github.event.pull_request.base.ref == 'main'

    steps:
      - name: Check if auto-merge criteria met
        uses: actions/github-script@v7
        id: check
        with:
          script: |
            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            // Check reviews
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const approvals = reviews.filter(r => r.state === 'APPROVED');
            const changesRequested = reviews.filter(r => r.state === 'CHANGES_REQUESTED');

            // Check Copilot comments
            const { data: reviewComments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const unresolvedCopilotComments = reviewComments.filter(c =>
              c.user.login.includes('copilot') && !c.resolved
            );

            // Determine if can auto-merge
            const canAutoMerge =
              approvals.length >= 1 &&
              changesRequested.length === 0 &&
              unresolvedCopilotComments.length === 0;

            core.info(`Auto-merge criteria:`);
            core.info(`  Approvals: ${approvals.length}/1`);
            core.info(`  Changes requested: ${changesRequested.length}`);
            core.info(`  Unresolved Copilot comments: ${unresolvedCopilotComments.length}`);

            return canAutoMerge;

      - name: Enable auto-merge
        if: steps.check.outputs.result == 'true'
        run: |
          gh pr merge --auto --squash "$PR_URL"
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Comment auto-merge status
        uses: actions/github-script@v7
        with:
          script: |
            const canMerge = ${{ steps.check.outputs.result }};

            if (canMerge) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `üöÄ **Auto-merge enabled!**

This PR will be automatically merged when all status checks pass.

**Criteria Met:**
- ‚úÖ At least 1 approval
- ‚úÖ No change requests
- ‚úÖ All Copilot comments resolved
- ‚úÖ All CI checks passing`
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `‚è∏Ô∏è **Auto-merge not enabled**

This PR does not yet meet auto-merge criteria. Required:
- At least 1 approval
- No change requests
- All Copilot review comments resolved
- All CI checks passing

Please address any outstanding feedback.`
              });
            }

  # ==========================================
  # Job 5: Auto-Resolve Copilot Comments
  # ==========================================
  resolve-copilot-comments:
    name: üìù Auto-Resolve Addressed Comments
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'synchronize'
    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Auto-resolve addressed comments
        uses: actions/github-script@v7
        with:
          script: |
            // Get all review comments
            const { data: comments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            // Filter unresolved Copilot comments (top-level only)
            const copilotComments = comments.filter(c =>
              c.user.login.includes('copilot') &&
              !c.in_reply_to_id  // Top-level comments only
            );

            if (copilotComments.length === 0) {
              core.info('‚úÖ No Copilot comments found');
              return;
            }

            // Get changed files in latest push
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const changedFiles = new Set(files.map(f => f.filename));
            let resolvedCount = 0;
            let alreadyResolved = 0;

            // Check each comment
            for (const comment of copilotComments) {
              // Skip if already has resolution reply
              const { data: replies } = await github.rest.pulls.listCommentsForReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                review_id: comment.pull_request_review_id
              }).catch(() => ({ data: [] }));

              const hasResolutionReply = replies.some(r =>
                r.body.includes('‚úÖ Auto-resolved') || r.body.includes('‚úÖ Resolved')
              );

              if (hasResolutionReply) {
                alreadyResolved++;
                continue;
              }

              // Check if file was modified
              if (changedFiles.has(comment.path)) {
                try {
                  // Add resolution reply
                  await github.rest.pulls.createReplyForReviewComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: context.issue.number,
                    comment_id: comment.id,
                    body: '‚úÖ **Auto-resolved**: File was modified in latest commit.\n\n' +
                          '‚ÑπÔ∏è If this issue persists, Copilot will comment again on the next review.'
                  });

                  resolvedCount++;
                  core.info(`‚úÖ Auto-resolved comment on ${comment.path}:${comment.line || 'N/A'}`);
                } catch (error) {
                  core.warning(`Failed to resolve comment ${comment.id}: ${error.message}`);
                }
              }
            }

            // Post summary if any changes
            if (resolvedCount > 0 || alreadyResolved > 0) {
              const total = copilotComments.length;
              const unresolved = total - resolvedCount - alreadyResolved;

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `ü§ñ **Copilot Comment Auto-Resolution Summary**\n\n` +
                      `‚úÖ Newly resolved: **${resolvedCount}**\n` +
                      `‚úîÔ∏è Previously resolved: **${alreadyResolved}**\n` +
                      `‚è≥ Remaining unresolved: **${unresolved}**\n\n` +
                      (unresolved > 0
                        ? `‚ÑπÔ∏è To view remaining comments, run:\n\`\`\`bash\n./scripts/pr-manager.sh copilot ${context.issue.number}\n\`\`\``
                        : `üéâ All Copilot comments have been addressed!`)
              });

              core.info(`üìä Summary: ${resolvedCount} newly resolved, ${alreadyResolved} previously resolved, ${unresolved} remaining`);
            }
